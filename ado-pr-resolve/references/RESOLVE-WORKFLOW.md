# PR Comment Resolution ‚Äî Detailed Workflow Reference

Complete step-by-step reference for resolving active PR comments using multi-model AI analysis.

---

## Step 1: Parse PR URL

### Supported Formats

```
Format A: https://dev.azure.com/{org}/{project}/_git/{repo}/pullrequest/{prId}
Format B: https://{org}.visualstudio.com/{project}/_git/{repo}/pullrequest/{prId}
```

### Extraction Logic

**Format A** (`dev.azure.com`):
```
URL segments: /dev.azure.com/{org}/{project}/_git/{repo}/pullrequest/{prId}
                              [1]    [2]           [4]               [6]
```

**Format B** (`visualstudio.com`):
```
Hostname: {org}.visualstudio.com
URL segments: /{project}/_git/{repo}/pullrequest/{prId}
               [1]             [3]               [5]
```

### Validation
- `prId` must be a positive integer
- `org`, `project`, `repo` must be non-empty
- URL must contain `/_git/` and `/pullrequest/`

### URL Decoding
- Project names may be URL-encoded: `Database%20Systems` ‚Üí `Database Systems`
- Repo names are usually plain text but decode just in case

---

## Step 2: Authentication

```bash
# 1. Verify Azure CLI login
az account show
# If not logged in: az login

# 2. Get access token for Azure DevOps
TOKEN=$(az account get-access-token \
  --resource 499b84ac-1321-427f-aa17-267ca6975798 \
  --query accessToken -o tsv)

# 3. Test token by fetching PR
curl -s -o /dev/null -w "%{http_code}" \
  "https://dev.azure.com/{org}/{project}/_apis/git/repositories/{repo}/pullrequests/{prId}?api-version=7.1" \
  -H "Authorization: Bearer $TOKEN"
# Expected: 200
```

### Auth Failure Handling
- **401/403**: Token expired or wrong account. Run `az login` and retry.
- **az not found**: User needs Azure CLI installed.
- **Token empty**: `az account get-access-token` failed ‚Äî check subscription/login state.

---

## Step 3: Fetch PR Metadata

```bash
curl -s "https://dev.azure.com/{org}/{project}/_apis/git/repositories/{repo}/pullrequests/{prId}?api-version=7.1" \
  -H "Authorization: Bearer $TOKEN" | jq '{
    sourceRefName,
    targetRefName,
    title,
    status,
    createdBy: .createdBy.displayName
  }'
```

**Extract:**
- `sourceRefName` ‚Üí strip `refs/heads/` prefix to get branch name
- `targetRefName` ‚Üí target branch for diff comparison
- `status` ‚Üí must be `active` (can't resolve comments on completed/abandoned PRs)

---

## Step 4: Fetch & Filter Active Threads

### Fetch All Threads

```bash
THREADS=$(curl -s \
  "https://dev.azure.com/{org}/{project}/_apis/git/repositories/{repo}/pullRequests/{prId}/threads?api-version=7.0" \
  -H "Authorization: Bearer $TOKEN")
```

### Filtering Logic

Apply these filters in order:

1. **Status filter:** Keep only `status === "active"`
   - Skip: `fixed`, `closed`, `wontFix`, `byDesign`, `pending`

2. **System thread filter:** Skip threads where:
   - `comments[0].commentType === "system"` (auto-generated by ADO)
   - Thread has no `threadContext` (PR-level system messages like "X voted", "policies updated")
   - First comment contains auto-generated text patterns: "Merge conflict", "This file was"

3. **Deleted comment filter:** Skip threads where all comments have `isDeleted: true`

4. **Self-comment filter (optional):** Optionally skip threads where the comment author is the same as the PR creator (reviewer commenting on their own PR is usually a note, not a request)

### Data Extraction Per Thread

For each surviving thread, extract:

```json
{
  "threadId": 123,
  "filePath": "/src/file.cpp",
  "startLine": 42,
  "endLine": 45,
  "author": "Reviewer Name",
  "rootComment": "The full text of the first comment",
  "replies": [
    {
      "author": "Another Person",
      "content": "Reply text",
      "commentId": 2
    }
  ],
  "rootCommentId": 1
}
```

### Thread Ordering

Process threads in file order (group by `filePath`, then by `startLine`) for logical flow. This way related comments on the same file are handled sequentially.

---

## Step 5: Checkout PR Source Branch

```bash
# Navigate to repo
cd {repo_path}

# Fetch latest
git fetch origin

# Extract branch names (strip refs/heads/)
SOURCE_BRANCH=$(echo "{sourceRefName}" | sed 's|refs/heads/||')
TARGET_BRANCH=$(echo "{targetRefName}" | sed 's|refs/heads/||')

# Checkout source branch
git checkout "$SOURCE_BRANCH"
# Or if you want an isolated branch:
git checkout -b resolve/{prId} origin/"$SOURCE_BRANCH"
```

### Branch Checkout Failures
- **Dirty working directory:** Stash changes first (`git stash`)
- **Branch doesn't exist locally:** `git fetch origin "$SOURCE_BRANCH"` first
- **Merge conflicts on checkout:** Abort and notify user

---

## Step 6: Per-Comment Model Prompt Construction

### Gather Context for Each Thread

#### a) Full Thread Text

Concatenate all comments in the thread with attribution:

```
Thread by {author}:
"{root comment text}"

Reply by {reply_author}:
"{reply text}"

Reply by {another_author}:
"{another reply}"
```

#### b) Code Context (¬±50 lines)

```bash
# Calculate line range
CONTEXT_START=$((startLine - 50))
[ "$CONTEXT_START" -lt 1 ] && CONTEXT_START=1
CONTEXT_END=$((endLine + 50))

# Extract code with line numbers
sed -n "${CONTEXT_START},${CONTEXT_END}p" "{filePath}" | nl -ba -nln -v"$CONTEXT_START"
```

#### c) File Diff

```bash
git diff origin/"$TARGET_BRANCH"...HEAD -- "{filePath}"
```

### Build the Prompt

```
You are reviewing a code review comment on a pull request.

## Comment
Thread by {author}: "{root_comment_text}"
{all replies with attribution}

## Code Context (file: {filePath}, lines {contextStart}-{contextEnd})
{code with line numbers}

## Diff for this file
{diff output}

Tasks:
1. Explain what the reviewer is asking for
2. Assess if the comment is valid
3. Propose a concrete code fix (show exact before/after)
4. If you disagree with the reviewer, explain why

Output format:
ASSESSMENT: <valid|partially_valid|disagree>
EXPLANATION: <what the reviewer wants>
FIX:
```before
<original code>
```
```after
<fixed code>
```
REASONING: <why this fix addresses the comment>
```

Save prompt to `/tmp/resolve_prompt_{threadId}.txt` to avoid shell escaping issues.

---

## Step 7: Run Multi-Model Analysis

### Parallel Execution

```bash
# Claude Opus 4.5
copilot --model claude-opus-4.5 --allow-all-tools --no-ask-user \
  -p "$(cat /tmp/resolve_prompt_{threadId}.txt)" > /tmp/resolve_opus_{threadId}.txt 2>&1 &

# GPT 5.2 Codex
copilot --model gpt-5.2-codex --allow-all-tools --no-ask-user \
  -p "$(cat /tmp/resolve_prompt_{threadId}.txt)" > /tmp/resolve_codex_{threadId}.txt 2>&1 &

# Gemini Pro 3
copilot --model gemini-3-pro-preview --allow-all-tools --no-ask-user \
  -p "$(cat /tmp/resolve_prompt_{threadId}.txt)" > /tmp/resolve_gemini_{threadId}.txt 2>&1 &

wait
```

### Sub-Agent Approach

For better chat responsiveness, spawn a sub-agent per thread (or batch of threads) using `sessions_spawn`:

1. Sub-agent runs the 3 model queries
2. Sub-agent parses and consolidates results
3. Sub-agent writes results to temp file
4. Sub-agent announces completion back to chat

This keeps the main chat session responsive while heavy model work happens in the background.

---

## Step 8: Result Consolidation Logic

### Parse Model Output

For each model, extract the structured fields:

```
ASSESSMENT: valid | partially_valid | disagree
EXPLANATION: <text>
FIX:
  before: <original code block>
  after: <replacement code block>
REASONING: <text>
```

### Agreement Detection

Compare the 3 model responses:

1. **Assessment agreement:** Do 2+ models give the same `ASSESSMENT` value?
2. **Fix agreement:** Do 2+ models propose semantically equivalent code changes?
   - Exact match: identical `after` blocks
   - Semantic match: same logical change with minor formatting/style differences

### Confidence Assignment

| Scenario | Confidence | Action |
|----------|------------|--------|
| All 3 agree on assessment AND fix | **HIGH** | Present consensus fix |
| 2 agree on fix, 1 differs | **HIGH** | Present majority fix, note dissent |
| All agree on assessment, fixes differ slightly | **HIGH** | Present best fix (prefer clearest), note variations |
| Models split on assessment (2-1) | **MEDIUM** | Present majority view, show dissenting perspective |
| All 3 disagree | **MEDIUM** | Present all 3 perspectives, let user decide |

### Consensus Fix Selection

When models agree, select the fix to present:
1. If fixes are identical ‚Üí use any
2. If semantically equivalent ‚Üí prefer the most readable/idiomatic version
3. If 2 agree and 1 differs ‚Üí use the majority fix

---

## Step 9: User Presentation Format

### Per-Comment Display

```
üìù Comment #{n} by {author} on {file}:{line}
> "{comment text}"

ü§ñ AI Council Assessment (confidence: {HIGH|MEDIUM}):

**What they want:** {consolidated explanation}

**Proposed fix:**
```diff
- old code
+ new code
```

**Model breakdown:**
- Claude: {assessment} ‚Äî {brief reasoning}
- Codex: {assessment} ‚Äî {brief reasoning}
- Gemini: {assessment} ‚Äî {brief reasoning}
```

### Inline Action Buttons (Telegram)

| Button | Action |
|--------|--------|
| ‚úÖ Apply fix | Apply the proposed code change, reply to ADO thread, mark thread as fixed |
| üí¨ Discuss | User can ask follow-up questions; models can re-analyze with additional context |
| ‚è≠Ô∏è Skip | Move to the next comment without action |
| ‚úèÔ∏è Edit fix | User provides a modified version of the fix, then apply |

### Discuss Flow

When user clicks üí¨ Discuss:
1. Accept user's question or concern
2. Optionally re-query models with the additional context
3. Present updated analysis
4. Re-show action buttons

### Edit Fix Flow

When user clicks ‚úèÔ∏è Edit fix:
1. Show the current proposed fix
2. Accept user's modified version
3. Apply the user's version instead
4. Proceed with reply & resolve as normal

---

## Step 10: Apply Code Fix

### File Modification

Use precise text replacement to apply the fix:

```bash
# Option A: Using the Edit tool for exact text replacement
# oldText = the "before" block from the fix
# newText = the "after" block from the fix

# Option B: Using sed for simple replacements
sed -i 's/old_pattern/new_pattern/g' "{filePath}"

# Option C: For multi-line changes, write to temp file and use patch
```

### Stage the Change

```bash
git add "{filePath}"
```

### Verify Fix

After applying, verify:
1. File still parses correctly (no syntax errors introduced)
2. The change matches what was approved
3. No unintended side effects on adjacent code

---

## Step 11: Reply & Resolve on ADO

### Post Reply to Thread

```bash
cat > /tmp/reply_{threadId}.json << 'EOF'
{
  "content": "Fixed: {brief explanation of the change}",
  "parentCommentId": {rootCommentId},
  "commentType": 1
}
EOF

curl -s -X POST \
  "https://dev.azure.com/{org}/{project}/_apis/git/repositories/{repo}/pullRequests/{prId}/threads/{threadId}/comments?api-version=7.0" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d @/tmp/reply_{threadId}.json
```

### Update Thread Status

```bash
curl -s -X PATCH \
  "https://dev.azure.com/{org}/{project}/_apis/git/repositories/{repo}/pullRequests/{prId}/threads/{threadId}?api-version=7.0" \
  -H "Authorization: Bearer $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"status": "fixed"}'
```

### Reply Content Guidelines

- Keep it brief: "Fixed: Changed X to Y to address Z"
- Include code snippet if the change is non-obvious
- Don't include the full AI analysis ‚Äî just the summary
- Be professional (this is visible to all PR participants)

---

## Step 12: Commit & Push

### After All Comments Processed

```bash
# Check what's staged
git status

# Commit with descriptive message
git add -A
git commit -m "Address PR review comments

Resolved comments:
- {file1}:{line1}: {brief fix description}
- {file2}:{line2}: {brief fix description}
Skipped: {n} comments"

# ASK USER before pushing
# "Ready to push. Push changes to origin/{branch}?"
git push origin {branch}
```

---

## Error Handling

### Authentication Errors

| Error | Detection | Recovery |
|-------|-----------|----------|
| Token expired | 401 response | `TOKEN=$(az account get-access-token ...)` ‚Äî re-fetch |
| Wrong account | 403 response | `az login` with correct account |
| No CLI | `az: command not found` | Tell user to install Azure CLI |

### Network Errors

| Error | Detection | Recovery |
|-------|-----------|----------|
| Timeout | curl timeout | Retry with `--max-time 30` |
| DNS failure | curl error 6 | Check internet connectivity |
| SSL error | curl error 60 | Check system certificates |

### Git Errors

| Error | Detection | Recovery |
|-------|-----------|----------|
| Dirty working directory | `git checkout` fails | `git stash` first, unstash after |
| Merge conflict on checkout | conflict markers | Abort, notify user |
| Branch not found | `git fetch` fails | Verify branch name from PR metadata |
| Push rejected | `git push` fails | `git pull --rebase` then retry |

### Model Query Errors

| Error | Detection | Recovery |
|-------|-----------|----------|
| Copilot not installed | `copilot: command not found` | Tell user to install GitHub Copilot CLI |
| Model unavailable | Error in output | Skip that model, continue with remaining 2 |
| Timeout | Process hangs > 5min | Kill process, retry or skip |
| Empty output | 0-byte output file | Retry once, then skip that model |
| Malformed output | Can't parse ASSESSMENT/FIX | Use raw output, present to user as-is |

### ADO API Errors

| Error | Detection | Recovery |
|-------|-----------|----------|
| Thread already resolved | 409 Conflict | Skip ‚Äî someone else resolved it |
| Thread not found | 404 | Thread may have been deleted; skip |
| PR completed | Thread operations fail | Warn user ‚Äî PR may have been merged |
| Rate limited | 429 | Wait 5 seconds, retry |

---

## Edge Cases

### Comment on Deleted File

**Detection:** File referenced in `threadContext.filePath` doesn't exist in the current source branch.

**Handling:**
1. Check if file exists: `test -f "{filePath}"`
2. If missing, check git log: `git log --diff-filter=D -- "{filePath}"`
3. Present to user:
   ```
   ‚ö†Ô∏è Comment #{n} on {file}:{line} ‚Äî file has been deleted
   > "{comment text}"
   
   This file no longer exists in the source branch.
   Options: üí¨ Discuss | ‚è≠Ô∏è Skip | üîÑ Resolve as "won't fix"
   ```
4. User can resolve as `wontFix` or discuss further

### Comment on Changed Lines

**Detection:** The line numbers in the thread context no longer match the current code (lines were added/removed above the commented location).

**Handling:**
1. Use `git diff` to detect line shifts
2. Try to locate the original code using content matching (search for the commented code text)
3. If found at a different line, adjust and proceed
4. If not found (code was rewritten), present:
   ```
   ‚ö†Ô∏è Comment #{n} on {file}:{line} ‚Äî code has changed since this comment
   > "{comment text}"
   
   The commented code has been modified. Original context may not apply.
   Current code at that location:
   {current code}
   
   Options: üí¨ Discuss | ‚è≠Ô∏è Skip
   ```

### Multi-Line Comments

**Detection:** `rightFileStart.line !== rightFileEnd.line`

**Handling:**
- Use the full line range for code context
- Ensure the fix covers the entire commented range
- When applying fixes, replace the full range, not just a single line

### Comment Thread with Extensive Discussion

**Detection:** Thread has many replies (>5 comments).

**Handling:**
- Still send ALL comments to the models (full context matters)
- Focus the models on the latest unresolved ask
- Present a summary of the discussion in the user-facing output

### Concurrent Modifications

**Detection:** Another developer pushes to the same branch while you're working.

**Handling:**
1. Before pushing, always `git fetch` and check for upstream changes
2. If upstream changed: `git pull --rebase origin {branch}`
3. If rebase conflicts: stop, notify user, let them resolve manually
4. Never force-push

### No Active Comments

**Detection:** Thread fetch returns no threads with `status: "active"`.

**Handling:**
```
‚úÖ No active review comments on this PR!
All threads are either resolved or system-generated.
```

### Comments Without File Context

**Detection:** Thread exists but `threadContext` is null (PR-level comment, not file-specific).

**Handling:**
- These are general PR comments, not line-specific
- Present the comment but note it's PR-level
- Models can still analyze if it refers to specific code by name
- Skip the code context / diff sections in the prompt

---

## State Management

### State File: `memory/pr-resolve-state.json`

```json
{
  "active_pr": {
    "url": "https://dev.azure.com/msdata/Database%20Systems/_git/RgManager/pullrequest/12345",
    "org": "msdata",
    "project": "Database Systems",
    "repo": "RgManager",
    "prId": 12345,
    "sourceBranch": "feature/xyz",
    "targetBranch": "main",
    "threads": [
      {
        "threadId": 100,
        "status": "pending",
        "file": "/src/file.cpp",
        "line": 42,
        "comment": "Consider using const reference here",
        "author": "Reviewer Name",
        "fix_applied": null,
        "fix_description": null,
        "ado_replied": false,
        "ado_resolved": false
      },
      {
        "threadId": 101,
        "status": "resolved",
        "file": "/src/util.h",
        "line": 78,
        "comment": "Thread safety issue",
        "author": "Another Reviewer",
        "fix_applied": "Changed raw pointer to shared_ptr",
        "fix_description": "Fixed: Used shared_ptr for thread-safe reference counting",
        "ado_replied": true,
        "ado_resolved": true
      }
    ],
    "current_thread_index": 1,
    "started_at": "2026-02-03T21:30:00Z",
    "last_updated": "2026-02-03T21:45:00Z"
  }
}
```

### State Transitions

```
pending ‚Üí resolved   (user approved fix, applied & resolved on ADO)
pending ‚Üí skipped    (user chose to skip)
pending ‚Üí discussing (user wants to discuss further)
discussing ‚Üí resolved (user approved after discussion)
discussing ‚Üí skipped  (user decided to skip after discussion)
```

### State Recovery

If the session is interrupted mid-workflow:
1. Read `memory/pr-resolve-state.json`
2. Resume from `current_thread_index`
3. Skip threads already marked `resolved` or `skipped`
4. Re-fetch token (likely expired)
5. Verify git branch is still correct

---

## Summary Flow

```
Parse URL ‚Üí Auth ‚Üí Fetch Threads ‚Üí Filter Active ‚Üí Checkout Branch
    ‚Üì
For each active thread:
    ‚Üì
Gather Context ‚Üí Spawn Sub-Agent ‚Üí 3 Models Analyze ‚Üí Consolidate
    ‚Üì
Present to User (with inline buttons)
    ‚Üì
User Decision:
  ‚úÖ Apply ‚Üí Edit file ‚Üí Stage ‚Üí Reply on ADO ‚Üí Resolve on ADO ‚Üí Next
  üí¨ Discuss ‚Üí Back-and-forth ‚Üí Re-present ‚Üí User Decision
  ‚è≠Ô∏è Skip ‚Üí Next
  ‚úèÔ∏è Edit ‚Üí User modifies fix ‚Üí Apply ‚Üí Reply ‚Üí Resolve ‚Üí Next
    ‚Üì
All comments processed ‚Üí git commit ‚Üí Ask to push ‚Üí Done
```
